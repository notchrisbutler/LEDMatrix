<div class="card shadow-sm">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h6 class="card-title mb-0"><i class="fas fa-file-alt me-2"></i>System Logs</h6>
        <p class="text-muted small mb-0 d-none d-md-block">Real-time logs from the LED matrix service</p>
    </div>
    <div class="card-body pb-2">
        <!-- Controls -->
        <div class="d-flex flex-wrap align-items-center justify-content-between gap-2 mb-3">
            <div class="d-flex align-items-center gap-3">
                <!-- Log Mode Toggle -->
                <div class="d-flex align-items-center gap-2">
                    <div class="form-check form-switch mb-0">
                        <input type="checkbox" id="log-realtime-toggle" class="form-check-input" checked>
                        <label class="form-check-label small fw-medium" for="log-realtime-toggle">Real-time</label>
                    </div>
                    <button id="refresh-logs-btn" class="btn btn-sm btn-outline-secondary">
                        <i class="fas fa-sync-alt me-1"></i>Refresh
                    </button>
                </div>

                <!-- Log Level Filter -->
                <select id="log-level-filter" class="form-select form-select-sm" style="width: auto;">
                    <option value="">All Levels</option>
                    <option value="ERROR">Errors Only</option>
                    <option value="WARNING">Warnings & Errors</option>
                    <option value="INFO">Info & Above</option>
                </select>

                <!-- Search -->
                <div class="position-relative">
                    <input type="text" id="log-search" placeholder="Search logs..." class="form-control form-control-sm ps-4" style="width: 200px;">
                    <i class="fas fa-search position-absolute top-50 translate-middle-y text-muted" style="left: 0.5rem; font-size: 0.75rem;"></i>
                </div>
            </div>

            <div class="d-flex align-items-center gap-2">
                <!-- Auto-scroll toggle -->
                <div class="form-check form-switch mb-0">
                    <input type="checkbox" id="log-autoscroll" class="form-check-input" checked>
                    <label class="form-check-label small" for="log-autoscroll">Auto-scroll</label>
                </div>

                <!-- Clear logs -->
                <button id="clear-logs-btn" class="btn btn-sm btn-outline-danger">
                    <i class="fas fa-trash me-1"></i>Clear
                </button>

                <!-- Download logs -->
                <button id="download-logs-btn" class="btn btn-sm btn-outline-success">
                    <i class="fas fa-download me-1"></i>Download
                </button>
            </div>
        </div>
    </div>

    <!-- Log Display -->
    <div class="card-body p-0 position-relative">
        <div id="logs-container" class="log-viewer position-relative" style="height: 600px; min-height: 400px; max-height: 70vh;">
            <div id="logs-loading" class="d-flex align-items-center justify-content-center text-secondary">
                <div class="text-center">
                    <i class="fas fa-spinner fa-spin fs-4 mb-2"></i>
                    <p>Loading logs...</p>
                </div>
            </div>
            <div id="logs-display" class="d-none">
                <div class="logs-content p-0">
                    <!-- Logs will be inserted here -->
                </div>
            </div>
            <div id="logs-empty" class="d-none d-flex align-items-center justify-content-center text-secondary">
                <div class="text-center">
                    <i class="fas fa-file-alt fs-1 mb-2"></i>
                    <p>No logs available</p>
                    <p class="small mt-2">Logs will appear here when the service runs</p>
                </div>
            </div>
        </div>

        <!-- Log stats -->
        <div id="log-stats" class="position-absolute top-0 end-0 m-2 bg-dark bg-opacity-75 text-white small px-2 py-1 rounded d-none">
            <i class="fas fa-list-ul me-1"></i>
            <span id="log-count">0</span> entries
        </div>
    </div>

    <!-- Connection Status -->
    <div class="card-footer">
        <div id="log-connection-status" class="small text-muted d-flex align-items-center gap-2">
            <span class="d-inline-block rounded-circle bg-success" style="width: 0.5rem; height: 0.5rem;"></span>
            <span>Connected to log stream</span>
        </div>
    </div>
</div>

<script>
// Global variables - use window properties to avoid redeclaration errors with HTMX reloads
// Initialize only if not already defined
if (typeof window._logsEventSource === 'undefined') {
    window._logsEventSource = null;
}
if (typeof window._allLogs === 'undefined') {
    window._allLogs = [];
}
if (typeof window._filteredLogs === 'undefined') {
    window._filteredLogs = [];
}
if (typeof window._logContainer === 'undefined') {
    window._logContainer = null;
}
if (typeof window._logsContent === 'undefined') {
    window._logsContent = null;
}
if (typeof window._isRealtime === 'undefined') {
    window._isRealtime = true;
}
if (typeof window._MAX_LOGS === 'undefined') {
    window._MAX_LOGS = 500; // Maximum number of logs to keep in memory
}

// Use window properties directly to avoid redeclaration issues
// Clean up any existing event source before reinitializing
if (window._logsEventSource) {
    window._logsEventSource.close();
    window._logsEventSource = null;
}

// Reset arrays on reload
window._allLogs = [];
window._filteredLogs = [];

// Initialize immediately (this script runs when the partial is loaded)
(function() {
    window._logContainer = document.getElementById('logs-container');
    window._logsContent = document.querySelector('#logs-display .logs-content');

    // Logs container initialized successfully

    initializeLogs();

    // Event listeners - remove old ones first to prevent duplicates
    const realtimeToggle = document.getElementById('log-realtime-toggle');
    const refreshBtn = document.getElementById('refresh-logs-btn');
    const levelFilter = document.getElementById('log-level-filter');
    const searchInput = document.getElementById('log-search');
    const autoscrollToggle = document.getElementById('log-autoscroll');
    const clearBtn = document.getElementById('clear-logs-btn');
    const downloadBtn = document.getElementById('download-logs-btn');

    // Clone and replace to remove old listeners
    if (realtimeToggle) {
        const newToggle = realtimeToggle.cloneNode(true);
        realtimeToggle.parentNode.replaceChild(newToggle, realtimeToggle);
        newToggle.addEventListener('change', toggleRealtime);
    }
    if (refreshBtn) {
        const newBtn = refreshBtn.cloneNode(true);
        refreshBtn.parentNode.replaceChild(newBtn, refreshBtn);
        newBtn.addEventListener('click', refreshLogs);
    }
    if (levelFilter) {
        const newFilter = levelFilter.cloneNode(true);
        levelFilter.parentNode.replaceChild(newFilter, levelFilter);
        newFilter.addEventListener('change', filterLogs);
    }
    if (searchInput) {
        const newInput = searchInput.cloneNode(true);
        searchInput.parentNode.replaceChild(newInput, searchInput);
        newInput.addEventListener('input', filterLogs);
    }
    if (autoscrollToggle) {
        const newToggle = autoscrollToggle.cloneNode(true);
        autoscrollToggle.parentNode.replaceChild(newToggle, autoscrollToggle);
        newToggle.addEventListener('change', toggleAutoscroll);
    }
    if (clearBtn) {
        const newBtn = clearBtn.cloneNode(true);
        clearBtn.parentNode.replaceChild(newBtn, clearBtn);
        newBtn.addEventListener('click', clearLogs);
    }
    if (downloadBtn) {
        const newBtn = downloadBtn.cloneNode(true);
        downloadBtn.parentNode.replaceChild(newBtn, downloadBtn);
        newBtn.addEventListener('click', downloadLogs);
    }

    // Handle window resize for responsive height
    window.addEventListener('resize', function() {
        if (window._logContainer) {
            // Force a reflow to update sizing
            window._logContainer.style.display = 'none';
            window._logContainer.offsetHeight; // Trigger reflow
            window._logContainer.style.display = '';

            // Re-evaluate scroll position after resize
            setTimeout(function() {
                const distanceFromBottom = window._logContainer.scrollHeight - window._logContainer.scrollTop - window._logContainer.clientHeight;
                window._isUserNearBottom = distanceFromBottom <= window._scrollThreshold;
            }, 100);
        }
    });
})();

function initializeLogs() {
    // Load initial logs
    loadLogs();

    // Setup SSE for real-time logs
    setupRealtimeLogs();

    // Setup auto-scroll
    setupAutoscroll();
}

function loadLogs() {
    showLoading();

    fetch('/api/v3/logs')
        .then(response => response.json())
        .then(data => {
            hideLoading();

            if (data.status === 'success' && data.data && data.data.logs) {
                processLogs(data.data.logs);
                updateLogStats();
            } else {
                showEmptyState();
            }
        })
        .catch(error => {
            hideLoading();
            showError('Failed to load logs: ' + error.message);
        });
}

function setupRealtimeLogs() {
    if (window._logsEventSource) {
        window._logsEventSource.close();
    }

    window._logsEventSource = new EventSource('/api/v3/stream/logs');

    window._logsEventSource.onopen = function() {
        document.getElementById('log-connection-status').innerHTML = `
            <span class="d-inline-block rounded-circle bg-success" style="width: 0.5rem; height: 0.5rem;"></span>
            <span>Connected to log stream</span>
        `;
    };

    window._logsEventSource.onmessage = function(event) {
        const data = JSON.parse(event.data);

        if (data.logs && window._isRealtime) {
            processLogs(data.logs, true);
            updateLogStats();

            // Use the new smart scroll function
            scrollToBottomIfNeeded();
        }
    };

    window._logsEventSource.onerror = function() {
        document.getElementById('log-connection-status').innerHTML = `
            <span class="d-inline-block rounded-circle bg-danger" style="width: 0.5rem; height: 0.5rem;"></span>
            <span>Disconnected from log stream</span>
        `;

        // Attempt to reconnect after 5 seconds
        setTimeout(setupRealtimeLogs, 5000);
    };
}

function processLogs(logsText, append = false) {
    if (!append) {
        window._allLogs = [];
        if (window._logsContent) {
            window._logsContent.innerHTML = '';
        }

        // Container cleared for new logs
    }

    // Parse journalctl output
    const lines = logsText.split('\n').filter(line => line.trim());

    lines.forEach(line => {
        // Skip empty lines
        if (!line.trim()) return;

        // Try to parse journalctl format: "MMM DD HH:MM:SS hostname service[pid]: message"
        // Example: "Oct 13 14:23:45 raspberrypi ledmatrix[1234]: INFO: Starting display"

        let timestamp = '';
        let level = 'INFO';
        let message = line;

        // Extract timestamp (first part before hostname)
        const timestampMatch = line.match(/^([A-Z][a-z]{2}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})/);
        if (timestampMatch) {
            timestamp = timestampMatch[1];

            // Find the message part (after service name and pid)
            const messageMatch = line.match(/:\s*(.+)$/);
            if (messageMatch) {
                message = messageMatch[1];

                // Detect log level from message
                if (message.match(/\b(ERROR|CRITICAL|FATAL)\b/i)) {
                    level = 'ERROR';
                } else if (message.match(/\b(WARNING|WARN)\b/i)) {
                    level = 'WARNING';
                } else if (message.match(/\bDEBUG\b/i)) {
                    level = 'DEBUG';
                } else if (message.match(/\bINFO\b/i)) {
                    level = 'INFO';
                }

                // Clean up level prefix from message if it exists
                message = message.replace(/^(ERROR|WARNING|WARN|INFO|DEBUG):\s*/i, '');
            }
        } else {
            // If no timestamp, use current time
            timestamp = new Date().toLocaleString('en-US', {
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }

        const logEntry = {
            timestamp: timestamp,
            level: level,
            message: message,
            raw: line,
            id: Date.now() + Math.random()
        };

        // Don't add duplicate entries when appending
        if (!append || !window._allLogs.find(log => log.raw === line)) {
            window._allLogs.push(logEntry);
        }
    });

    // Trim logs if we exceed the maximum
    if (window._allLogs.length > window._MAX_LOGS) {
        window._allLogs = window._allLogs.slice(-window._MAX_LOGS);
    }

    filterLogs();
}

function renderLogs() {
    if (window._filteredLogs.length === 0) {
        showEmptyState();
        return;
    }

    showLogs();

    if (window._logsContent) {
        window._logsContent.innerHTML = '';
    }

    window._filteredLogs.forEach(log => {
        const logElement = document.createElement('div');
        logElement.className = `log-entry py-1 px-2 rounded ${getLogLevelClass(log.level)}`;
        logElement.innerHTML = `
            <div class="d-flex align-items-start gap-2" style="font-size: 0.75rem; font-family: 'JetBrains Mono', monospace;">
                <span class="log-timestamp text-secondary flex-shrink-0" style="width: 8rem;">${escapeHtml(log.timestamp)}</span>
                <span class="log-level flex-shrink-0 badge ${getLogLevelBadgeClass(log.level)}">${log.level}</span>
                <span class="log-message flex-grow-1 ${getLogLevelTextClass(log.level)}" style="word-break: break-word;">${escapeHtml(log.message)}</span>
            </div>
        `;
        if (window._logsContent) {
            window._logsContent.appendChild(logElement);
        }
    });
}

function getLogLevelClass(level) {
    // Background color for the entire log entry row
    const classes = {
        'ERROR': 'log-level-error',
        'WARNING': 'log-level-warning',
        'INFO': '',
        'DEBUG': 'log-level-debug'
    };
    return classes[level] || '';
}

function getLogLevelBadgeClass(level) {
    const classes = {
        'ERROR': 'bg-danger',
        'WARNING': 'bg-warning text-dark',
        'INFO': 'bg-info text-dark',
        'DEBUG': 'bg-secondary'
    };
    return classes[level] || 'bg-secondary';
}

function getLogLevelTextClass(level) {
    const classes = {
        'ERROR': 'text-danger-emphasis',
        'WARNING': 'text-warning-emphasis',
        'INFO': 'text-light',
        'DEBUG': 'text-secondary'
    };
    return classes[level] || 'text-light';
}

function filterLogs() {
    const levelFilterEl = document.getElementById('log-level-filter');
    const searchEl = document.getElementById('log-search');
    if (!levelFilterEl || !searchEl) return;

    const levelFilter = levelFilterEl.value;
    const searchTerm = searchEl.value.toLowerCase();

    window._filteredLogs = window._allLogs.filter(log => {
        // Level filter
        if (levelFilter) {
            const levels = {
                'ERROR': ['ERROR'],
                'WARNING': ['ERROR', 'WARNING'],
                'INFO': ['ERROR', 'WARNING', 'INFO']
            };

            if (!levels[levelFilter].includes(log.level)) {
                return false;
            }
        }

        // Search filter
        if (searchTerm && !log.message.toLowerCase().includes(searchTerm)) {
            return false;
        }

        return true;
    });

    renderLogs();
    updateLogStats();
}

function toggleRealtime() {
    const toggleEl = document.getElementById('log-realtime-toggle');
    if (!toggleEl) return;

    window._isRealtime = toggleEl.checked;

    if (window._isRealtime) {
        setupRealtimeLogs();
    } else if (window._logsEventSource) {
        window._logsEventSource.close();
        window._logsEventSource = null;
    }
}

function refreshLogs() {
    loadLogs();
    if (typeof showNotification !== 'undefined') {
        showNotification('Logs refreshed', 'success');
    }
}

function clearLogs() {
    window._allLogs = [];
    window._filteredLogs = [];
    if (window._logsContent) {
        window._logsContent.innerHTML = '';
    }
    showEmptyState();
    updateLogStats();
    if (typeof showNotification !== 'undefined') {
        showNotification('Logs cleared', 'info');
    }
}

function downloadLogs() {
    if (window._filteredLogs.length === 0) {
        if (typeof showNotification !== 'undefined') {
            showNotification('No logs to download', 'warning');
        }
        return;
    }

    const logText = window._filteredLogs.map(log => log.raw).join('\n');
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `ledmatrix-logs-${new Date().toISOString().slice(0, 19)}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    if (typeof showNotification !== 'undefined') {
        showNotification('Logs downloaded', 'success');
    }
}

// Track if user is near bottom for smart auto-scroll
if (typeof window._isUserNearBottom === 'undefined') {
    window._isUserNearBottom = true;
}
if (typeof window._scrollThreshold === 'undefined') {
    window._scrollThreshold = 100; // pixels from bottom to consider "near bottom"
}

function setupAutoscroll() {
    if (!window._logsContent) return;

    const observer = new MutationObserver(function() {
        // Use requestAnimationFrame for better timing
        requestAnimationFrame(scrollToBottomIfNeeded);
    });
    observer.observe(window._logsContent, { childList: true });

    // Also listen for manual scroll events to detect when user is not at bottom
    if (window._logContainer) {
        window._logContainer.addEventListener('scroll', function() {
            const distanceFromBottom = window._logContainer.scrollHeight - window._logContainer.scrollTop - window._logContainer.clientHeight;
            window._isUserNearBottom = distanceFromBottom <= window._scrollThreshold;
        });
    }
}

function scrollToBottomIfNeeded() {
    const autoscrollEl = document.getElementById('log-autoscroll');
    if (autoscrollEl && autoscrollEl.checked && window._logContainer && window._isUserNearBottom) {
        // Use requestAnimationFrame for smooth scrolling
        requestAnimationFrame(function() {
            // Remember current scroll position
            const previousScrollHeight = window._logContainer.scrollHeight;

            // Scroll to bottom
            window._logContainer.scrollTop = window._logContainer.scrollHeight;

            // Ensure we're actually at the bottom after a brief delay
            setTimeout(function() {
                if (window._logContainer.scrollTop + window._logContainer.clientHeight >= window._logContainer.scrollHeight - 10) {
                    window._isUserNearBottom = true;
                }
            }, 50);
        });
    }
}

function scrollToBottom() {
    // Legacy function for backward compatibility
    if (window._logContainer) {
        window._logContainer.scrollTop = window._logContainer.scrollHeight;
        window._isUserNearBottom = true;
    }
}

function toggleAutoscroll() {
    const autoscrollEl = document.getElementById('log-autoscroll');
    if (!autoscrollEl || !autoscrollEl.checked) {
        // Don't auto-scroll if unchecked or element doesn't exist
        window._isUserNearBottom = false;
        return;
    }

    // Scroll to bottom when re-enabled and user was near bottom
    if (window._isUserNearBottom) {
        scrollToBottom();
    }
}

function updateLogStats() {
    const stats = document.getElementById('log-stats');
    const count = document.getElementById('log-count');

    if (stats && count) {
        count.textContent = window._filteredLogs.length;
        stats.classList.remove('d-none');
    }
}

function showLoading() {
    document.getElementById('logs-loading').classList.remove('d-none');
    document.getElementById('logs-display').classList.add('d-none');
    document.getElementById('logs-empty').classList.add('d-none');
}

function showLogs() {
    document.getElementById('logs-loading').classList.add('d-none');
    document.getElementById('logs-display').classList.remove('d-none');
    document.getElementById('logs-empty').classList.add('d-none');
}

function hideLoading() {
    document.getElementById('logs-loading').classList.add('d-none');
}

function showEmptyState() {
    document.getElementById('logs-loading').classList.add('d-none');
    document.getElementById('logs-display').classList.add('d-none');
    document.getElementById('logs-empty').classList.remove('d-none');
    document.getElementById('log-stats').classList.add('d-none');
}

function showError(message) {
    if (window._logsContent) {
        window._logsContent.innerHTML = `<div class="text-danger p-3">${escapeHtml(message)}</div>`;
        window._logsContent.classList.remove('d-none');
    }
}

// Utility function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (window._logsEventSource) {
        window._logsEventSource.close();
    }
});
</script>
