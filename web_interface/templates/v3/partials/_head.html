    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Matrix Control Panel - v3</title>

    <!-- Google Fonts: DM Sans (headings), Source Sans 3 (body), JetBrains Mono (code) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Source+Sans+3:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Theme initialization (must run before CSS to prevent flash) -->
    <script>
    (function() {
        // Safely read from localStorage (may throw in private browsing / restricted contexts)
        function getStorage(key) {
            try { return localStorage.getItem(key); } catch (e) { return null; }
        }
        function setStorage(key, value) {
            try { localStorage.setItem(key, value); } catch (e) { /* no-op */ }
        }

        // Safely query prefers-color-scheme (matchMedia may be unavailable)
        function prefersDark() {
            try {
                return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            } catch (e) { return false; }
        }

        var saved = getStorage('theme');
        var theme = saved || (prefersDark() ? 'dark' : 'light');
        document.documentElement.setAttribute('data-bs-theme', theme);

        // Theme toggle function
        window.toggleTheme = function() {
            try {
                var current = document.documentElement.getAttribute('data-bs-theme');
                var next = current === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-bs-theme', next);
                setStorage('theme', next);
                window.updateThemeIcon(next);
            } catch (e) { /* no-op */ }
        };

        // Update icon visibility and ARIA state based on current theme
        window.updateThemeIcon = function(theme) {
            var darkIcon = document.getElementById('theme-icon-dark');
            var lightIcon = document.getElementById('theme-icon-light');
            var btn = document.getElementById('theme-toggle');
            if (darkIcon && lightIcon) {
                if (theme === 'dark') {
                    darkIcon.classList.add('hidden');
                    lightIcon.classList.remove('hidden');
                } else {
                    darkIcon.classList.remove('hidden');
                    lightIcon.classList.add('hidden');
                }
            }
            if (btn) {
                var isDark = theme === 'dark';
                btn.setAttribute('aria-pressed', String(isDark));
                var label = isDark ? 'Switch to light mode' : 'Switch to dark mode';
                btn.setAttribute('aria-label', label);
                btn.setAttribute('title', label);
            }
        };

        // Initialize icon state once DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            window.updateThemeIcon(document.documentElement.getAttribute('data-bs-theme') || 'light');
        });

        // Listen for OS theme changes (only when no explicit user preference)
        try {
            var mql = window.matchMedia('(prefers-color-scheme: dark)');
            var handler = function(e) {
                if (!getStorage('theme')) {
                    var t = e.matches ? 'dark' : 'light';
                    document.documentElement.setAttribute('data-bs-theme', t);
                    window.updateThemeIcon(t);
                }
            };
            if (mql.addEventListener) {
                mql.addEventListener('change', handler);
            } else if (mql.addListener) {
                mql.addListener(handler);
            }
        } catch (e) { /* matchMedia unavailable */ }
    })();
    </script>

    <!-- Resource hints for CDN resources -->
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="https://unpkg.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">

    <!-- Bootstrap 5.3 CSS (CDN with AP mode fallback) -->
    <script>
    (function() {
        var isAPMode = window.location.hostname === '192.168.4.1' ||
                       window.location.hostname.startsWith('192.168.4.');
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = isAPMode
            ? '/static/v3/vendor/bootstrap.min.css'
            : 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css';
        document.head.appendChild(link);
    })();
    </script>

    <!-- HTMX for dynamic content loading -->
    <!-- Use local files when in AP mode (192.168.4.x) to avoid CDN dependency -->
    <script>
        (function() {
            // Detect AP mode by IP address
            const isAPMode = window.location.hostname === '192.168.4.1' || 
                           window.location.hostname.startsWith('192.168.4.');
            
            // In AP mode, use local files; otherwise use CDN
            const htmxSrc = isAPMode ? '/static/v3/js/htmx.min.js' : 'https://unpkg.com/htmx.org@1.9.10';
            const sseSrc = isAPMode ? '/static/v3/js/htmx-sse.js' : 'https://unpkg.com/htmx.org/dist/ext/sse.js';
            const jsonEncSrc = isAPMode ? '/static/v3/js/htmx-json-enc.js' : 'https://unpkg.com/htmx.org/dist/ext/json-enc.js';
            
            // Load HTMX with fallback
            function loadScript(src, fallback, onLoad) {
                const script = document.createElement('script');
                script.src = src;
                script.onload = onLoad || (() => {});
                script.onerror = function() {
                    if (fallback && src !== fallback) {
                        console.warn(`Failed to load ${src}, trying fallback ${fallback}`);
                        const fallbackScript = document.createElement('script');
                        fallbackScript.src = fallback;
                        fallbackScript.onload = onLoad || (() => {});
                        document.head.appendChild(fallbackScript);
                    } else {
                        console.error(`Failed to load script: ${src}`);
                    }
                };
                document.head.appendChild(script);
            }
            
            // Load HTMX core
            loadScript(htmxSrc, isAPMode ? 'https://unpkg.com/htmx.org@1.9.10' : '/static/v3/js/htmx.min.js', function() {
                // Wait a moment for HTMX to initialize, then verify
                setTimeout(function() {
                    // Verify HTMX loaded
                    if (typeof htmx === 'undefined') {
                        console.error('HTMX failed to load, trying fallback...');
                        const fallbackSrc = isAPMode ? 'https://unpkg.com/htmx.org@1.9.10' : '/static/v3/js/htmx.min.js';
                        if (fallbackSrc !== htmxSrc) {
                            loadScript(fallbackSrc, null, function() {
                                setTimeout(function() {
                                    if (typeof htmx !== 'undefined') {
                                        console.log('HTMX loaded from fallback');
                                        // Load extensions after core loads
                                        loadScript(sseSrc, isAPMode ? 'https://unpkg.com/htmx.org/dist/ext/sse.js' : '/static/v3/js/htmx-sse.js');
                                        loadScript(jsonEncSrc, isAPMode ? 'https://unpkg.com/htmx.org/dist/ext/json-enc.js' : '/static/v3/js/htmx-json-enc.js');
                                    } else {
                                        console.error('HTMX failed to load from both primary and fallback sources');
                                        // Trigger fallback content loading
                                        window.dispatchEvent(new Event('htmx-load-failed'));
                                    }
                                }, 100);
                            });
                        } else {
                            console.error('HTMX failed to load and no fallback available');
                            window.dispatchEvent(new Event('htmx-load-failed'));
                        }
                    } else {
                        console.log('HTMX loaded successfully');
                        // Load extensions after core loads
                        loadScript(sseSrc, isAPMode ? 'https://unpkg.com/htmx.org/dist/ext/sse.js' : '/static/v3/js/htmx-sse.js');
                        loadScript(jsonEncSrc, isAPMode ? 'https://unpkg.com/htmx.org/dist/ext/json-enc.js' : '/static/v3/js/htmx-json-enc.js');
                    }
                }, 100);
            });
        })();
    </script>
    <script>
        // Configure HTMX to evaluate scripts in swapped content and fix insertBefore errors
        (function() {
            function setupScriptExecution() {
                if (document.body) {
                    // Fix HTMX insertBefore errors by validating targets before swap
                    document.body.addEventListener('htmx:beforeSwap', function(event) {
                        try {
                            const target = event.detail.target;
                            if (!target) {
                                console.warn('[HTMX] Target is null, skipping swap');
                                event.detail.shouldSwap = false;
                                return false;
                            }
                            
                            // Check if target is a valid DOM element
                            if (!(target instanceof Element)) {
                                console.warn('[HTMX] Target is not a valid Element, skipping swap');
                                event.detail.shouldSwap = false;
                                return false;
                            }
                            
                            // Check if target has a parent node (required for insertBefore)
                            if (!target.parentNode) {
                                console.warn('[HTMX] Target has no parent node, skipping swap');
                                event.detail.shouldSwap = false;
                                return false;
                            }
                            
                            // Ensure target is in the DOM
                            if (!document.body.contains(target) && !document.head.contains(target)) {
                                console.warn('[HTMX] Target is not in DOM, skipping swap');
                                event.detail.shouldSwap = false;
                                return false;
                            }
                            
                            // Additional check: ensure parent is also in DOM
                            if (target.parentNode && !document.body.contains(target.parentNode) && !document.head.contains(target.parentNode)) {
                                console.warn('[HTMX] Target parent is not in DOM, skipping swap');
                                event.detail.shouldSwap = false;
                                return false;
                            }
                            
                            // All checks passed, allow swap
                            return true;
                        } catch (e) {
                            // If validation fails, cancel swap
                            console.warn('[HTMX] Error validating target:', e);
                            event.detail.shouldSwap = false;
                            return false;
                        }
                    });
                    
                    // Suppress HTMX insertBefore errors and other noisy errors - they're harmless but noisy
                    const originalError = console.error;
                    const originalWarn = console.warn;
                    
                    console.error = function(...args) {
                        const errorStr = args.join(' ');
                        const errorStack = args.find(arg => arg && typeof arg === 'string' && arg.includes('htmx')) || '';
                        
                        // Suppress HTMX insertBefore errors (comprehensive check)
                        // These occur when HTMX tries to swap content but the target element is null
                        // Usually happens due to timing/race conditions and is harmless
                        if (errorStr.includes("insertBefore") || 
                            errorStr.includes("Cannot read properties of null") ||
                            errorStr.includes("reading 'insertBefore'")) {
                            // Check if it's from HTMX by looking at stack trace or error string
                            // Also check the call stack if available
                            const isHtmxError = errorStr.includes('htmx.org') || 
                                               errorStr.includes('htmx') || 
                                               errorStack.includes('htmx') ||
                                               args.some(arg => {
                                                   if (typeof arg === 'string') {
                                                       return arg.includes('htmx.org') || arg.includes('htmx');
                                                   }
                                                   // Check error objects for stack traces
                                                   if (arg && typeof arg === 'object' && arg.stack) {
                                                       return arg.stack.includes('htmx');
                                                   }
                                                   return false;
                                               });
                            
                            if (isHtmxError) {
                                return; // Suppress - this is a harmless HTMX timing/race condition issue
                            }
                        }
                        
                        // Suppress script execution errors from malformed HTML
                        if (errorStr.includes("Failed to execute 'appendChild' on 'Node'") ||
                            errorStr.includes("Failed to execute 'insertBefore' on 'Node'")) {
                            if (errorStr.includes('Unexpected token')) {
                                return; // Suppress malformed HTML errors
                            }
                        }
                        originalError.apply(console, args);
                    };
                    
                    console.warn = function(...args) {
                        const warnStr = args.join(' ');
                        // Suppress Permissions-Policy warnings (harmless browser warnings)
                        if (warnStr.includes('Permissions-Policy header') ||
                            warnStr.includes('Unrecognized feature') ||
                            warnStr.includes('Origin trial controlled feature') ||
                            warnStr.includes('browsing-topics') ||
                            warnStr.includes('run-ad-auction') ||
                            warnStr.includes('join-ad-interest-group') ||
                            warnStr.includes('private-state-token') ||
                            warnStr.includes('private-aggregation') ||
                            warnStr.includes('attribution-reporting')) {
                            return; // Suppress - these are harmless browser feature warnings
                        }
                        originalWarn.apply(console, args);
                    };
                    
                    // Handle HTMX errors gracefully with detailed logging
                    document.body.addEventListener('htmx:responseError', function(event) {
                        const detail = event.detail;
                        const xhr = detail.xhr;
                        const target = detail.target;
                        
                        // Enhanced error logging
                        console.error('HTMX response error:', {
                            status: xhr?.status,
                            statusText: xhr?.statusText,
                            url: xhr?.responseURL,
                            target: target?.id || target?.tagName,
                            responseText: xhr?.responseText
                        });
                        
                        // For form submissions, log the form data
                        if (target && target.tagName === 'FORM') {
                            const formData = new FormData(target);
                            const formPayload = {};
                            for (const [key, value] of formData.entries()) {
                                formPayload[key] = value;
                            }
                            console.error('Form payload:', formPayload);
                            
                            // Try to parse error response for validation details
                            if (xhr?.responseText) {
                                try {
                                    const errorData = JSON.parse(xhr.responseText);
                                    console.error('Error details:', {
                                        message: errorData.message,
                                        details: errorData.details,
                                        validation_errors: errorData.validation_errors,
                                        context: errorData.context
                                    });
                                } catch (e) {
                                    console.error('Error response (non-JSON):', xhr.responseText.substring(0, 500));
                                }
                            }
                        }
                    });
                    
                    document.body.addEventListener('htmx:swapError', function(event) {
                        // Log but don't break the app
                        console.warn('HTMX swap error:', event.detail);
                    });
                    
                    document.body.addEventListener('htmx:afterSwap', function(event) {
                        if (event.detail && event.detail.target) {
                            try {
                                const scripts = event.detail.target.querySelectorAll('script');
                                scripts.forEach(function(oldScript) {
                                    try {
                                        if (oldScript.innerHTML.trim() || oldScript.src) {
                                            const newScript = document.createElement('script');
                                            if (oldScript.src) newScript.src = oldScript.src;
                                            if (oldScript.type) newScript.type = oldScript.type;
                                            if (oldScript.innerHTML) newScript.textContent = oldScript.innerHTML;
                                            if (oldScript.parentNode) {
                                                oldScript.parentNode.insertBefore(newScript, oldScript);
                                                oldScript.parentNode.removeChild(oldScript);
                                            } else {
                                                // If no parent, append to head or body
                                                (document.head || document.body).appendChild(newScript);
                                            }
                                        }
                                    } catch (e) {
                                        // Silently ignore script execution errors
                                    }
                                });
                            } catch (e) {
                                // Silently ignore errors in script processing
                            }
                        }
                    });
                } else {
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', setupScriptExecution);
                    } else {
                        setTimeout(setupScriptExecution, 100);
                    }
                }
            }
            setupScriptExecution();
            
            // Section toggle function - define early so it's available for HTMX-loaded content
            window.toggleSection = function(sectionId) {
                const section = document.getElementById(sectionId);
                const icon = document.getElementById(sectionId + '-icon');
                if (!section) {
                    console.warn('toggleSection: Could not find section for', sectionId);
                    return;
                }
                if (!icon) {
                    console.warn('toggleSection: Could not find icon for', sectionId);
                    return;
                }
                
                // Check if currently hidden by checking both class and computed display
                const hasHiddenClass = section.classList.contains('hidden');
                const computedDisplay = window.getComputedStyle(section).display;
                const isHidden = hasHiddenClass || computedDisplay === 'none';
                
                if (isHidden) {
                    // Show the section - remove hidden class and explicitly set display to block
                    section.classList.remove('hidden');
                    section.style.display = 'block';
                    icon.classList.remove('fa-chevron-right');
                    icon.classList.add('fa-chevron-down');
                } else {
                    // Hide the section - add hidden class and set display to none
                    section.classList.add('hidden');
                    section.style.display = 'none';
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-right');
                }
            };
            
            // Function to load plugins tab
            window.loadPluginsTab = function() {
                const content = document.getElementById('plugins-content');
                if (content && !content.hasAttribute('data-loaded')) {
                    content.setAttribute('data-loaded', 'true');
                    console.log('Loading plugins directly via fetch...');
                    
                    fetch('/v3/partials/plugins')
                        .then(r => r.text())
                        .then(html => {
                            // Parse HTML into a temporary container to extract scripts
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = html;
                            
                            // Extract scripts BEFORE inserting into DOM (browser may remove them)
                            const scripts = Array.from(tempDiv.querySelectorAll('script'));
                            console.log('Found', scripts.length, 'scripts to execute');
                            
                            // Insert content WITHOUT scripts first
                            const scriptsToExecute = [];
                            scripts.forEach(script => {
                                scriptsToExecute.push({
                                    content: script.textContent || script.innerHTML,
                                    src: script.src,
                                    type: script.type
                                });
                                script.remove(); // Remove from temp div
                            });
                            
                            // Now insert the HTML (without scripts)
                            content.innerHTML = tempDiv.innerHTML;
                            console.log('Plugins HTML loaded, executing', scriptsToExecute.length, 'scripts...');
                            
                            // Execute scripts manually - ensure they run properly
                            if (scriptsToExecute.length > 0) {
                                try {
                                    scriptsToExecute.forEach((scriptData, index) => {
                                    try {
                                        // Skip if script has no content and no src
                                        const scriptContent = scriptData.content ? scriptData.content.trim() : '';
                                        if (!scriptContent && !scriptData.src) {
                                            return;
                                        }
                                        
                                        // Log script info for debugging
                                        if (scriptContent) {
                                            const preview = scriptContent.substring(0, 100).replace(/\n/g, ' ');
                                            console.log(`[SCRIPT ${index + 1}] Content preview: ${preview}... (${scriptContent.length} chars)`);
                                            
                                            // Check if this script defines our critical functions
                                            if (scriptContent.includes('window.configurePlugin') || scriptContent.includes('window.togglePlugin')) {
                                                console.log(`[SCRIPT ${index + 1}] ⚠️  This script should define configurePlugin/togglePlugin!`);
                                            }
                                        }
                                        
                                        // Only execute if we have valid content
                                        if (scriptContent || scriptData.src) {
                                            // For inline scripts, use appendChild for reliable execution
                                            if (scriptContent && !scriptData.src) {
                                                // For very large scripts (>100KB), try fallback methods first
                                                // as appendChild can sometimes have issues with large scripts
                                                const isLargeScript = scriptContent.length > 100000;
                                                
                                                if (isLargeScript) {
                                                    console.log(`[SCRIPT ${index + 1}] Large script detected (${scriptContent.length} chars), trying fallback methods first...`);
                                                    
                                                    // Try Function constructor first for large scripts
                                                    let executed = false;
                                                    try {
                                                        const func = new Function('window', scriptContent);
                                                        func(window);
                                                        console.log(`[SCRIPT ${index + 1}] ✓ Executed large script via Function constructor`);
                                                        executed = true;
                                                    } catch (funcError) {
                                                        console.warn(`[SCRIPT ${index + 1}] Function constructor failed:`, funcError.message);
                                                    }
                                                    
                                                    // If Function constructor failed, try indirect eval
                                                    if (!executed) {
                                                        try {
                                                            (0, eval)(scriptContent);
                                                            console.log(`[SCRIPT ${index + 1}] ✓ Executed large script via indirect eval`);
                                                            executed = true;
                                                        } catch (evalError) {
                                                            console.warn(`[SCRIPT ${index + 1}] Indirect eval failed:`, evalError.message);
                                                        }
                                                    }
                                                    
                                                    // If both fallbacks worked, skip appendChild
                                                    if (executed) {
                                                        // Verify functions were defined
                                                        setTimeout(() => {
                                                            console.log(`[SCRIPT ${index + 1}] After fallback execution:`, {
                                                                configurePlugin: typeof window.configurePlugin,
                                                                togglePlugin: typeof window.togglePlugin
                                                            });
                                                        }, 50);
                                                        return; // Skip to next script (use return, not continue, in forEach)
                                                    }
                                                }
                                                
                                                try {
                                                    // Create new script element and append to head/body
                                                    // This ensures proper execution context and window attachment
                                                    const newScript = document.createElement('script');
                                                    if (scriptData.type) {
                                                        newScript.type = scriptData.type;
                                                    }
                                                    
                                                    // Wrap in a promise to wait for execution
                                                    const scriptPromise = new Promise((resolve, reject) => {
                                                        // Set up error handler
                                                        newScript.onerror = (error) => {
                                                            reject(error);
                                                        };
                                                        
                                                        // For inline scripts, execution happens synchronously when appended
                                                        // But we'll use a small delay to ensure it completes
                                                        try {
                                                            // Set textContent (not innerHTML) to avoid execution issues
                                                            // Note: We can't wrap in try-catch here as it would interfere with the script
                                                            // Instead, we rely on the script's own error handling
                                                            newScript.textContent = scriptContent;
                                                            
                                                            // Append to head for better execution context
                                                            const target = document.head || document.body;
                                                            if (target) {
                                                                // Set up error handler to catch execution errors
                                                                newScript.onerror = (error) => {
                                                                    console.error(`[SCRIPT ${index + 1}] Execution error:`, error);
                                                                    reject(error);
                                                                };
                                                                
                                                                // Check before execution
                                                                const beforeConfigurePlugin = typeof window.configurePlugin === 'function';
                                                                const beforeTogglePlugin = typeof window.togglePlugin === 'function';
                                                                
                                                                // Declare variables in outer scope so setTimeout can access them
                                                                let afterConfigurePlugin = beforeConfigurePlugin;
                                                                let afterTogglePlugin = beforeTogglePlugin;
                                                                
                                                                // Append and execute (execution is synchronous for inline scripts)
                                                                // Wrap in try-catch to catch any execution errors
                                                                try {
                                                                    target.appendChild(newScript);
                                                                    
                                                                    // Check immediately after append (inline scripts execute synchronously)
                                                                    afterConfigurePlugin = typeof window.configurePlugin === 'function';
                                                                    afterTogglePlugin = typeof window.togglePlugin === 'function';
                                                                    
                                                                    console.log(`[SCRIPT ${index + 1}] Immediate check after appendChild:`, {
                                                                        configurePlugin: { before: beforeConfigurePlugin, after: afterConfigurePlugin },
                                                                        togglePlugin: { before: beforeTogglePlugin, after: afterTogglePlugin }
                                                                    });
                                                                } catch (appendError) {
                                                                    console.error(`[SCRIPT ${index + 1}] Error during appendChild:`, appendError);
                                                                    console.error(`[SCRIPT ${index + 1}] Error message:`, appendError.message);
                                                                    console.error(`[SCRIPT ${index + 1}] Error stack:`, appendError.stack);
                                                                    
                                                                    // Try fallback execution methods immediately
                                                                    console.warn(`[SCRIPT ${index + 1}] Attempting fallback execution methods...`);
                                                                    let executed = false;
                                                                    
                                                                    // Method 1: Function constructor
                                                                    try {
                                                                        const func = new Function('window', scriptContent);
                                                                        func(window);
                                                                        console.log(`[SCRIPT ${index + 1}] ✓ Executed via Function constructor (fallback)`);
                                                                        executed = true;
                                                                    } catch (funcError) {
                                                                        console.warn(`[SCRIPT ${index + 1}] Function constructor failed:`, funcError.message);
                                                                        if (funcError.stack) {
                                                                            console.warn(`[SCRIPT ${index + 1}] Function constructor stack:`, funcError.stack);
                                                                        }
                                                                        // Try to find the line number if available
                                                                        if (funcError.message.includes('line')) {
                                                                            const lineMatch = funcError.message.match(/line (\d+)/);
                                                                            if (lineMatch) {
                                                                                const lineNum = parseInt(lineMatch[1]);
                                                                                const lines = scriptContent.split('\n');
                                                                                const start = Math.max(0, lineNum - 5);
                                                                                const end = Math.min(lines.length, lineNum + 5);
                                                                                console.warn(`[SCRIPT ${index + 1}] Context around error (lines ${start}-${end}):`, 
                                                                                    lines.slice(start, end).join('\n'));
                                                                            }
                                                                        }
                                                                    }
                                                                    
                                                                    // Method 2: Indirect eval
                                                                    if (!executed) {
                                                                        try {
                                                                            (0, eval)(scriptContent);
                                                                            console.log(`[SCRIPT ${index + 1}] ✓ Executed via indirect eval (fallback)`);
                                                                            executed = true;
                                                                        } catch (evalError) {
                                                                            console.warn(`[SCRIPT ${index + 1}] Indirect eval failed:`, evalError.message);
                                                                            if (evalError.stack) {
                                                                                console.warn(`[SCRIPT ${index + 1}] Indirect eval stack:`, evalError.stack);
                                                                            }
                                                                        }
                                                                    }
                                                                    
                                                                    // Check if functions are now defined
                                                                    const fallbackConfigurePlugin = typeof window.configurePlugin === 'function';
                                                                    const fallbackTogglePlugin = typeof window.togglePlugin === 'function';
                                                                    
                                                                    console.log(`[SCRIPT ${index + 1}] After fallback attempts:`, {
                                                                        configurePlugin: fallbackConfigurePlugin,
                                                                        togglePlugin: fallbackTogglePlugin,
                                                                        executed: executed
                                                                    });
                                                                    
                                                                    if (!executed) {
                                                                        reject(appendError);
                                                                    } else {
                                                                        resolve();
                                                                    }
                                                                }
                                                                
                                                                // Also check after a small delay to catch any async definitions
                                                                setTimeout(() => {
                                                                    const delayedConfigurePlugin = typeof window.configurePlugin === 'function';
                                                                    const delayedTogglePlugin = typeof window.togglePlugin === 'function';
                                                                    
                                                                    // Use the variables from the outer scope
                                                                    if (delayedConfigurePlugin !== afterConfigurePlugin || delayedTogglePlugin !== afterTogglePlugin) {
                                                                        console.log(`[SCRIPT ${index + 1}] Functions appeared after delay:`, {
                                                                            configurePlugin: { immediate: afterConfigurePlugin, delayed: delayedConfigurePlugin },
                                                                            togglePlugin: { immediate: afterTogglePlugin, delayed: delayedTogglePlugin }
                                                                        });
                                                                    }
                                                                    
                                                                    resolve();
                                                                }, 100); // Small delay to catch any async definitions
                                                            } else {
                                                                reject(new Error('No target found for script execution'));
                                                            }
                                                        } catch (appendError) {
                                                            reject(appendError);
                                                        }
                                                    });
                                                    
                                                    // Wait for script to execute (with timeout)
                                                    Promise.race([
                                                        scriptPromise,
                                                        new Promise((_, reject) => setTimeout(() => reject(new Error('Script execution timeout')), 1000))
                                                    ]).catch(error => {
                                                        console.warn(`[SCRIPT ${index + 1}] Script execution issue, trying fallback:`, error);
                                                        // Fallback: try multiple execution methods
                                                        let executed = false;
                                                        
                                                        // Method 1: Function constructor with window in scope
                                                        try {
                                                            const func = new Function('window', scriptContent);
                                                            func(window);
                                                            console.log(`[SCRIPT ${index + 1}] Executed via Function constructor (fallback method 1)`);
                                                            executed = true;
                                                        } catch (funcError) {
                                                            console.warn(`[SCRIPT ${index + 1}] Function constructor failed:`, funcError);
                                                        }
                                                        
                                                        // Method 2: Direct eval in global scope (if method 1 failed)
                                                        if (!executed) {
                                                            try {
                                                                // Use indirect eval to execute in global scope
                                                                (0, eval)(scriptContent);
                                                                console.log(`[SCRIPT ${index + 1}] Executed via indirect eval (fallback method 2)`);
                                                                executed = true;
                                                            } catch (evalError) {
                                                                console.warn(`[SCRIPT ${index + 1}] Indirect eval failed:`, evalError);
                                                            }
                                                        }
                                                        
                                                        // Verify functions after fallback
                                                        setTimeout(() => {
                                                            console.log(`[SCRIPT ${index + 1}] After fallback execution:`, {
                                                                configurePlugin: typeof window.configurePlugin,
                                                                togglePlugin: typeof window.togglePlugin,
                                                                executed: executed
                                                            });
                                                        }, 10);
                                                        
                                                        if (!executed) {
                                                            console.error(`[SCRIPT ${index + 1}] All script execution methods failed`);
                                                            console.error(`[SCRIPT ${index + 1}] Script content (first 500 chars):`, scriptContent.substring(0, 500));
                                                        }
                                                    });
                                                } catch (appendError) {
                                                    console.error('Failed to execute script:', appendError);
                                                }
                                            } else if (scriptData.src) {
                                                // For external scripts, use appendChild
                                                const newScript = document.createElement('script');
                                                newScript.src = scriptData.src;
                                                if (scriptData.type) {
                                                    newScript.type = scriptData.type;
                                                }
                                                const target = document.head || document.body;
                                                if (target) {
                                                    target.appendChild(newScript);
                                                }
                                                console.log('Loaded external script', index + 1, 'of', scriptsToExecute.length);
                                            }
                                        }
                                    } catch (scriptError) {
                                        console.warn('Error executing script', index + 1, ':', scriptError);
                                    }
                                });
                                
                                // Wait a moment for scripts to execute, then verify functions are available
                                // Use multiple checks to ensure scripts have time to execute
                                let checkCount = 0;
                                const maxChecks = 10;
                                const checkInterval = setInterval(() => {
                                    checkCount++;
                                    const funcs = {
                                        configurePlugin: typeof window.configurePlugin,
                                        togglePlugin: typeof window.togglePlugin,
                                        updatePlugin: typeof window.updatePlugin,
                                        uninstallPlugin: typeof window.uninstallPlugin,
                                        initializePlugins: typeof window.initializePlugins,
                                        loadInstalledPlugins: typeof window.loadInstalledPlugins,
                                        renderInstalledPlugins: typeof window.renderInstalledPlugins
                                    };
                                    
                                    if (checkCount === 1 || checkCount === maxChecks) {
                                        console.log('Verifying plugin functions after script execution (check', checkCount, '):', funcs);
                                    }
                                    
                                    // Stop checking once critical functions are available or max checks reached
                                    if ((funcs.configurePlugin === 'function' && funcs.togglePlugin === 'function') || checkCount >= maxChecks) {
                                        clearInterval(checkInterval);
                                        if (funcs.configurePlugin !== 'function' || funcs.togglePlugin !== 'function') {
                                            console.error('Critical plugin functions not available after', checkCount, 'checks');
                                        }
                                    }
                                }, 100);
                                } catch (executionError) {
                                    console.error('Script execution error:', executionError);
                                }
                            } else {
                                console.log('No scripts found in loaded HTML');
                            }
                            
                        // Wait for scripts to execute, then load plugins
                        // CRITICAL: Wait for configurePlugin and togglePlugin to be defined before proceeding
                        let attempts = 0;
                        const maxAttempts = 20; // Increased to give more time
                        const checkInterval = setInterval(() => {
                            attempts++;
                            
                            // First, ensure critical functions are available
                            const criticalFunctionsReady = 
                                window.configurePlugin && typeof window.configurePlugin === 'function' &&
                                window.togglePlugin && typeof window.togglePlugin === 'function';
                            
                            if (!criticalFunctionsReady && attempts < maxAttempts) {
                                if (attempts % 5 === 0) { // Log every 5th attempt
                                    console.log(`Waiting for critical functions... (attempt ${attempts}/${maxAttempts})`, {
                                        configurePlugin: typeof window.configurePlugin,
                                        togglePlugin: typeof window.togglePlugin
                                    });
                                }
                                return; // Keep waiting
                            }
                            
                            if (!criticalFunctionsReady) {
                                console.error('Critical functions (configurePlugin, togglePlugin) not available after', maxAttempts, 'attempts');
                                clearInterval(checkInterval);
                                return;
                            }
                            
                            console.log('Critical functions ready, proceeding with plugin initialization...');
                            clearInterval(checkInterval);
                            
                            // Now try to call initializePlugins first (loads both installed and store)
                            if (window.initializePlugins && typeof window.initializePlugins === 'function') {
                                console.log('Found initializePlugins, calling it...');
                                window.initializePlugins();
                            } else if (window.loadInstalledPlugins && typeof window.loadInstalledPlugins === 'function') {
                                console.log('Found loadInstalledPlugins, calling it...');
                                window.loadInstalledPlugins();
                                // Also try to load plugin store
                                if (window.searchPluginStore && typeof window.searchPluginStore === 'function') {
                                    setTimeout(() => window.searchPluginStore(true), 500);
                                }
                            } else if (window.pluginManager && window.pluginManager.loadInstalledPlugins) {
                                console.log('Found pluginManager.loadInstalledPlugins, calling it...');
                                window.pluginManager.loadInstalledPlugins();
                                // Also try to load plugin store
                                setTimeout(() => {
                                    const searchFn = window.searchPluginStore || 
                                                     (window.pluginManager && window.pluginManager.searchPluginStore);
                                    if (searchFn && typeof searchFn === 'function') {
                                        console.log('Loading plugin store...');
                                        searchFn(true);
                                    } else {
                                        console.warn('searchPluginStore not available');
                                    }
                                }, 500);
                            } else if (attempts >= maxAttempts) {
                                    console.log('loadInstalledPlugins not found after', maxAttempts, 'attempts, fetching and rendering directly...');
                                    clearInterval(checkInterval);
                                    
                                    // Load both installed plugins and plugin store
                                    Promise.all([
                                        // Use batched API requests for better performance
                                        window.PluginAPI && window.PluginAPI.batch ? 
                                            window.PluginAPI.batch([
                                                {endpoint: '/plugins/installed', method: 'GET'},
                                                {endpoint: '/plugins/store/list?fetch_commit_info=true', method: 'GET'}
                                            ]).then(([installedRes, storeRes]) => {
                                                return [installedRes, storeRes];
                                            }) :
                                            Promise.all([
                                                getInstalledPluginsSafe(),
                                                fetch('/api/v3/plugins/store/list?fetch_commit_info=true').then(r => r.json())
                                            ])
                                    ]).then(([installedData, storeData]) => {
                                        console.log('Fetched plugins:', installedData);
                                        console.log('Fetched store:', storeData);
                                        
                                        // Render installed plugins
                                        if (installedData.status === 'success') {
                                            const plugins = installedData.data.plugins || [];
                                            const container = document.getElementById('installed-plugins-grid');
                                            const countEl = document.getElementById('installed-count');
                                                
                                                // Try renderInstalledPlugins one more time
                                                if (window.renderInstalledPlugins && typeof window.renderInstalledPlugins === 'function') {
                                                    console.log('Using renderInstalledPlugins...');
                                                    window.renderInstalledPlugins(plugins);
                                } else if (container) {
                                    console.log('renderInstalledPlugins not available, rendering full plugin cards manually...');
                                    // Render full plugin cards with all information
                                    const escapeHtml = function(text) {
                                        if (!text) return '';
                                        const div = document.createElement('div');
                                        div.textContent = text;
                                        return div.innerHTML;
                                    };
                                    const escapeAttr = function(text) {
                                        return (text || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                                    };
                                    const escapeJs = function(text) {
                                        return JSON.stringify(text || '');
                                    };
                                    const formatCommit = function(commit, branch) {
                                        if (!commit && !branch) return 'Unknown';
                                        const shortCommit = commit ? String(commit).substring(0, 7) : '';
                                        const branchText = branch ? String(branch) : '';
                                        if (branchText && shortCommit) return branchText + ' · ' + shortCommit;
                                        if (branchText) return branchText;
                                        if (shortCommit) return shortCommit;
                                        return 'Unknown';
                                    };
                                    const formatDate = function(dateString) {
                                        if (!dateString) return 'Unknown';
                                        try {
                                            const date = new Date(dateString);
                                            if (isNaN(date.getTime())) return 'Unknown';
                                            const now = new Date();
                                            const diffDays = Math.ceil(Math.abs(now - date) / (1000 * 60 * 60 * 24));
                                            if (diffDays < 1) return 'Today';
                                            if (diffDays < 2) return 'Yesterday';
                                            if (diffDays < 7) return diffDays + ' days ago';
                                            if (diffDays < 30) {
                                                const weeks = Math.floor(diffDays / 7);
                                                return weeks + (weeks === 1 ? ' week' : ' weeks') + ' ago';
                                            }
                                            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                                        } catch (e) {
                                            return 'Unknown';
                                        }
                                    };
                                    container.innerHTML = plugins.map(function(p) {
                                        const name = escapeHtml(p.name || p.id);
                                        const desc = escapeHtml(p.description || 'No description available');
                                        const author = escapeHtml(p.author || 'Unknown');
                                        const category = escapeHtml(p.category || 'General');
                                        const enabled = p.enabled ? 'checked' : '';
                                        const enabledBool = Boolean(p.enabled);
                                        const escapedId = escapeAttr(p.id);
                                        const verified = p.verified ? '<span class="badge badge-success"><i class="fas fa-check-circle mr-1"></i>Verified</span>' : '';
                                        const tags = (p.tags && p.tags.length > 0) ? '<div class="flex flex-wrap gap-1.5 mb-4">' + p.tags.map(function(tag) { return '<span class="badge badge-info">' + escapeHtml(tag) + '</span>'; }).join('') + '</div>' : '';
                                        const escapedJsId = escapeJs(p.id);
                                        return '<div class="plugin-card"><div class="flex items-start justify-between mb-4"><div class="flex-1 min-w-0"><div class="flex items-center flex-wrap gap-2 mb-2"><h4 class="font-semibold text-gray-900 text-base">' + name + '</h4>' + verified + '</div><div class="text-sm text-gray-600 space-y-1.5 mb-3"><p class="flex items-center"><i class="fas fa-user mr-2 text-gray-400 w-4"></i>' + author + '</p><p class="flex items-center"><i class="fas fa-code-branch mr-2 text-gray-400 w-4"></i>' + formatCommit(p.last_commit, p.branch) + '</p><p class="flex items-center"><i class="fas fa-calendar mr-2 text-gray-400 w-4"></i>' + formatDate(p.last_updated) + '</p><p class="flex items-center"><i class="fas fa-folder mr-2 text-gray-400 w-4"></i>' + category + '</p></div><p class="text-sm text-gray-700 leading-relaxed">' + desc + '</p></div><div class="flex-shrink-0 ml-4"><label class="relative inline-flex items-center cursor-pointer group"><input type="checkbox" class="sr-only peer" id="toggle-' + escapedId + '" ' + enabled + ' data-plugin-id="' + escapedId + '" data-action="toggle" onchange=\'if(window.togglePlugin){window.togglePlugin(' + escapedJsId + ', this.checked)}else{console.error("togglePlugin not available")}\'><div class="flex items-center gap-2 px-3 py-1.5 rounded-lg border-2 transition-all duration-200 ' + (enabledBool ? 'bg-green-50 border-green-500' : 'bg-gray-50 border-gray-300') + ' hover:shadow-md group-hover:scale-105"><div class="relative w-14 h-7 ' + (enabledBool ? 'bg-green-500' : 'bg-gray-300') + ' rounded-full peer peer-checked:bg-green-500 transition-colors duration-200 ease-in-out shadow-inner"><div class="absolute top-[3px] left-[3px] bg-white ' + (enabledBool ? 'translate-x-full' : '') + ' border-2 ' + (enabledBool ? 'border-green-500' : 'border-gray-400') + ' rounded-full h-5 w-5 transition-all duration-200 ease-in-out shadow-sm flex items-center justify-center">' + (enabledBool ? '<i class="fas fa-check text-green-600 text-xs"></i>' : '<i class="fas fa-times text-gray-400 text-xs"></i>') + '</div></div><span class="text-sm font-semibold ' + (enabledBool ? 'text-green-700' : 'text-gray-600') + ' flex items-center gap-1.5"><i class="fas ' + (enabledBool ? 'fa-toggle-on text-green-600' : 'fa-toggle-off text-gray-400') + '"></i><span>' + (enabledBool ? 'Enabled' : 'Disabled') + '</span></span></div></label></div></div>' + tags + '<div class="flex flex-wrap gap-2 mt-4 pt-4 border-t border-gray-200"><button onclick=\'if(window.configurePlugin){window.configurePlugin(' + escapedJsId + ')}else{console.error("configurePlugin not available")}\' class="btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm flex-1 font-semibold" data-plugin-id="' + escapedId + '" data-action="configure"><i class="fas fa-cog mr-2"></i>Configure</button><button onclick=\'if(window.updatePlugin){window.updatePlugin(' + escapedJsId + ')}else{console.error("updatePlugin not available")}\' class="btn bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm flex-1 font-semibold" data-plugin-id="' + escapedId + '" data-action="update"><i class="fas fa-sync mr-2"></i>Update</button><button onclick=\'if(window.uninstallPlugin){window.uninstallPlugin(' + escapedJsId + ')}else{console.error("uninstallPlugin not available")}\' class="btn bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md text-sm flex-1 font-semibold" data-plugin-id="' + escapedId + '" data-action="uninstall"><i class="fas fa-trash mr-2"></i>Uninstall</button></div></div>';
                                    }).join('');
                                    if (countEl) countEl.textContent = plugins.length + ' installed';
                                    window.installedPlugins = plugins;
                                    console.log('Rendered', plugins.length, 'plugins with full cards');
                                } else {
                                    console.error('installed-plugins-grid container not found');
                                }
                                            }
                                        
                                        // Render plugin store
                                        if (storeData.status === 'success') {
                                            const storePlugins = storeData.data.plugins || [];
                                            const storeContainer = document.getElementById('plugin-store-grid');
                                            const storeCountEl = document.getElementById('store-count');
                                            
                                            if (storeContainer) {
                                                // Try renderPluginStore if available
                                                if (window.renderPluginStore && typeof window.renderPluginStore === 'function') {
                                                    console.log('Using renderPluginStore...');
                                                    window.renderPluginStore(storePlugins);
                                                } else {
                                                    // Manual rendering fallback
                                                    console.log('renderPluginStore not available, rendering manually...');
                                                    const escapeHtml = function(text) {
                                                        if (!text) return '';
                                                        const div = document.createElement('div');
                                                        div.textContent = text;
                                                        return div.innerHTML;
                                                    };
                                                    const escapeJs = function(text) {
                                                        return JSON.stringify(text || '');
                                                    };
                                                    storeContainer.innerHTML = storePlugins.map(function(p) {
                                                        const name = escapeHtml(p.name || p.id);
                                                        const desc = escapeHtml(p.description || 'No description available');
                                                        const author = escapeHtml(p.author || 'Unknown');
                                                        const category = escapeHtml(p.category || 'General');
                                                        const stars = p.stars || 0;
                                                        const verified = p.verified ? '<span class="badge badge-success"><i class="fas fa-check-circle mr-1"></i>Verified</span>' : '';
                                                        const escapedJsId = escapeJs(p.id);
                                                        return '<div class="plugin-card"><div class="flex items-start justify-between mb-4"><div class="flex-1 min-w-0"><div class="flex items-center flex-wrap gap-2 mb-2"><h4 class="font-semibold text-gray-900 text-base">' + name + '</h4>' + verified + '</div><div class="text-sm text-gray-600 space-y-1.5 mb-3"><p class="flex items-center"><i class="fas fa-user mr-2 text-gray-400 w-4"></i>' + author + '</p><p class="flex items-center"><i class="fas fa-folder mr-2 text-gray-400 w-4"></i>' + category + '</p>' + (stars > 0 ? '<p class="flex items-center"><i class="fas fa-star mr-2 text-gray-400 w-4"></i>' + stars + ' stars</p>' : '') + '</div><p class="text-sm text-gray-700 leading-relaxed">' + desc + '</p></div></div><div class="flex flex-wrap gap-2 mt-4 pt-4 border-t border-gray-200"><button onclick=\'if(window.installPlugin){window.installPlugin(' + escapedJsId + ')}else{console.error("installPlugin not available")}\' class="btn bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm flex-1 font-semibold"><i class="fas fa-download mr-2"></i>Install</button></div></div>';
                                                    }).join('');
                                                }
                                                
                                                if (storeCountEl) {
                                                    storeCountEl.innerHTML = storePlugins.length + ' available';
                                                }
                                                console.log('Rendered', storePlugins.length, 'store plugins');
                                            } else {
                                                console.error('plugin-store-grid container not found');
                                            }
                                        } else {
                                            console.error('Failed to load plugin store:', storeData.message);
                                            const storeCountEl = document.getElementById('store-count');
                                            if (storeCountEl) {
                                                storeCountEl.innerHTML = '<span class="text-red-600">Error loading store</span>';
                                            }
                                        }
                                    })
                                    .catch(err => {
                                        console.error('Error fetching plugins/store:', err);
                                        // Still try to render installed plugins if store fails
                                    });
                                }
                            }, 100); // Reduced from 200ms to 100ms for faster retries
                        })
                        .catch(err => console.error('Error loading plugins:', err));
                }
            };
        })();
    </script>

    <!-- Alpine.js app function - defined early so it's available when Alpine initializes -->
    <script>
        // Helper function to get installed plugins with fallback
        // Must be defined before app() function that uses it
        async function getInstalledPluginsSafe() {
            if (window.PluginAPI && window.PluginAPI.getInstalledPlugins) {
                try {
                    const plugins = await window.PluginAPI.getInstalledPlugins();
                    // Ensure plugins is always an array
                    const pluginsArray = Array.isArray(plugins) ? plugins : [];
                    return { status: 'success', data: { plugins: pluginsArray } };
                } catch (error) {
                    console.error('Error using PluginAPI.getInstalledPlugins, falling back to direct fetch:', error);
                    // Fall through to direct fetch
                }
            }
            // Fallback to direct fetch if PluginAPI not loaded
            const response = await fetch('/api/v3/plugins/installed');
            return await response.json();
        }

        // Global event listener for pluginsUpdated - works even if Alpine isn't ready yet
        // This ensures tabs update when plugins_manager.js loads plugins
        document.addEventListener('pluginsUpdated', function(event) {
            console.log('[GLOBAL] Received pluginsUpdated event:', event.detail?.plugins?.length || 0, 'plugins');
            const plugins = event.detail?.plugins || [];
            
            // Update window.installedPlugins
            window.installedPlugins = plugins;
            
            // Try to update Alpine component if it exists (only if using full implementation)
            if (window.Alpine) {
                const appElement = document.querySelector('[x-data="app()"]');
                if (appElement && appElement._x_dataStack && appElement._x_dataStack[0]) {
                    const appComponent = appElement._x_dataStack[0];
                    appComponent.installedPlugins = plugins;
                    // Only call updatePluginTabs if it's the full implementation (has _doUpdatePluginTabs)
                    if (typeof appComponent.updatePluginTabs === 'function' && 
                        appComponent.updatePluginTabs.toString().includes('_doUpdatePluginTabs')) {
                        console.log('[GLOBAL] Updating plugin tabs via Alpine component (full implementation)');
                        appComponent.updatePluginTabs();
                        return; // Full implementation handles it, don't do direct update
                    }
                }
            }
            
            // Only do direct DOM update if full implementation isn't available yet
            const pluginLists = document.querySelectorAll('.sidebar-plugin-list');
            if (pluginLists.length > 0 && plugins.length > 0) {
                pluginLists.forEach(pluginList => {
                    // Clear existing plugin tabs (except Plugin Manager)
                    const existingTabs = pluginList.querySelectorAll('.plugin-tab');
                    existingTabs.forEach(tab => tab.remove());

                    // Add tabs for each installed plugin
                    plugins.forEach(plugin => {
                        const li = document.createElement('li');
                        li.className = 'nav-item plugin-tab';
                        li.setAttribute('data-plugin-tab', plugin.id);
                        const a = document.createElement('a');
                        a.className = 'nav-link';
                        a.href = '#';
                        a.onclick = function(e) {
                            e.preventDefault();
                            // Try to set activeTab via Alpine if available
                            if (window.Alpine) {
                                const appElement = document.querySelector('[x-data="app()"]');
                                if (appElement && appElement._x_dataStack && appElement._x_dataStack[0]) {
                                    appElement._x_dataStack[0].activeTab = plugin.id;
                                    if (typeof appElement._x_dataStack[0].updatePluginTabStates === 'function') {
                                        appElement._x_dataStack[0].updatePluginTabStates();
                                    }
                                }
                            }
                            closeMobileNav();
                        };
                        a.innerHTML = `<i class="fas fa-puzzle-piece fa-fw"></i> ${(plugin.name || plugin.id).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}`;
                        li.appendChild(a);
                        pluginList.appendChild(li);
                    });
                });
                console.log('[GLOBAL] Updated sidebar plugin tabs directly:', plugins.length, 'tabs added');
            }
        });

        // Define app() function early so Alpine can find it when it initializes
        // This is a complete implementation that will work immediately
        (function() {
            const isAPMode = window.location.hostname === '192.168.4.1' || 
                           window.location.hostname.startsWith('192.168.4.');
            
            // Create the app function - will be enhanced by full implementation later
            window.app = function() {
                return {
                    activeTab: isAPMode ? 'wifi' : 'overview',
                    installedPlugins: [],
                    
                    init() {
                        // Try to enhance immediately with full implementation
                        const tryEnhance = () => {
                            if (typeof window.app === 'function') {
                                const fullApp = window.app();
                                // Check if this is the full implementation (has updatePluginTabs with proper implementation)
                                if (fullApp && typeof fullApp.updatePluginTabs === 'function' && fullApp.updatePluginTabs.toString().includes('_doUpdatePluginTabs')) {
                                    // Full implementation is available, copy all methods
                                    // But preserve _initialized flag to prevent double init
                                    const wasInitialized = this._initialized;
                                    Object.assign(this, fullApp);
                                    // Restore _initialized flag if it was set
                                    if (wasInitialized) {
                                        this._initialized = wasInitialized;
                                    }
                                    // Only call init if not already initialized
                                    if (typeof this.init === 'function' && !this._initialized) {
                                        this.init();
                                    }
                                    return true;
                                }
                            }
                            return false;
                        };
                        
                        // Set up event listener for pluginsUpdated in stub (only if not already enhanced)
                        // The full implementation will have its own listener, so we only need this for the stub
                        if (!this._pluginsUpdatedListenerSet) {
                            const handlePluginsUpdated = (event) => {
                                console.log('[STUB] Received pluginsUpdated event:', event.detail?.plugins?.length || 0, 'plugins');
                                const plugins = event.detail?.plugins || [];
                                // Only update if we're still in stub mode (not enhanced yet)
                                if (typeof this.updatePluginTabs === 'function' && !this.updatePluginTabs.toString().includes('_doUpdatePluginTabs')) {
                                    this.installedPlugins = plugins;
                                    if (this.$nextTick && typeof this.$nextTick === 'function') {
                                        this.$nextTick(() => {
                                            this.updatePluginTabs();
                                        });
                                    } else {
                                        setTimeout(() => {
                                            this.updatePluginTabs();
                                        }, 100);
                                    }
                                }
                            };
                            document.addEventListener('pluginsUpdated', handlePluginsUpdated);
                            this._pluginsUpdatedListenerSet = true;
                            console.log('[STUB] init: Set up pluginsUpdated event listener');
                        }
                        
                        // Try immediately - if full implementation is already loaded, use it right away
                        if (!tryEnhance()) {
                            // Full implementation not ready yet, load plugins directly while waiting
                            this.loadInstalledPluginsDirectly();
                            // Try again very soon to enhance with full implementation
                            setTimeout(tryEnhance, 10);
                            
                            // Also set up a periodic check to update tabs if plugins get loaded by plugins_manager.js
                            let retryCount = 0;
                            const maxRetries = 20; // Check for 2 seconds (20 * 100ms)
                            const checkAndUpdateTabs = () => {
                                if (retryCount >= maxRetries) {
                                    // Fallback: if plugins_manager.js hasn't loaded after 2 seconds, fetch directly
                                    if (!window.installedPlugins || window.installedPlugins.length === 0) {
                                        console.log('[STUB] checkAndUpdateTabs: Fallback - fetching plugins directly after timeout');
                                        this.loadInstalledPluginsDirectly();
                                    }
                                    return;
                                }
                                
                                // Check if plugins are available (either from window or component)
                                const plugins = window.installedPlugins || this.installedPlugins || [];
                                if (plugins.length > 0) {
                                    console.log('[STUB] checkAndUpdateTabs: Found', plugins.length, 'plugins, updating tabs');
                                    this.installedPlugins = plugins;
                                    if (typeof this.updatePluginTabs === 'function') {
                                        this.updatePluginTabs();
                                    }
                                } else {
                                    retryCount++;
                                    setTimeout(checkAndUpdateTabs, 100);
                                }
                            };
                            // Start checking after a short delay
                            setTimeout(checkAndUpdateTabs, 200);
                        } else {
                            // Full implementation loaded, but still set up fallback timer
                            setTimeout(() => {
                                if (!window.installedPlugins || window.installedPlugins.length === 0) {
                                    console.log('[STUB] init: Fallback timer - fetching plugins directly');
                                    this.loadInstalledPluginsDirectly();
                                }
                            }, 2000);
                        }
                    },
                    
                    // Direct plugin loading for stub (before full implementation loads)
                    async loadInstalledPluginsDirectly() {
                        try {
                            console.log('[STUB] loadInstalledPluginsDirectly: Starting...');
                            // Ensure DOM is ready
                            const ensureDOMReady = () => {
                                return new Promise((resolve) => {
                                    if (document.readyState === 'complete' || document.readyState === 'interactive') {
                                        // Use requestAnimationFrame to ensure DOM is painted
                                        requestAnimationFrame(() => {
                                            setTimeout(resolve, 50); // Small delay to ensure rendering
                                        });
                                    } else {
                                        document.addEventListener('DOMContentLoaded', () => {
                                            requestAnimationFrame(() => {
                                                setTimeout(resolve, 50);
                                            });
                                        });
                                    }
                                });
                            };
                            
                            await ensureDOMReady();
                            
                            const data = await getInstalledPluginsSafe();
                            if (data.status === 'success') {
                                const plugins = data.data.plugins || [];
                                console.log('[STUB] loadInstalledPluginsDirectly: Loaded', plugins.length, 'plugins');
                                
                                // Update both component and window
                                this.installedPlugins = plugins;
                                window.installedPlugins = plugins;
                                
                                // Dispatch event so global listener can update tabs
                                document.dispatchEvent(new CustomEvent('pluginsUpdated', {
                                    detail: { plugins: plugins }
                                }));
                                console.log('[STUB] loadInstalledPluginsDirectly: Dispatched pluginsUpdated event');
                                
                                // Update tabs if we have the method - use $nextTick if available
                                if (typeof this.updatePluginTabs === 'function') {
                                    if (this.$nextTick && typeof this.$nextTick === 'function') {
                                        this.$nextTick(() => {
                                            this.updatePluginTabs();
                                        });
                                    } else {
                                        // Fallback: wait a bit for DOM
                                        setTimeout(() => {
                                            this.updatePluginTabs();
                                        }, 100);
                                    }
                                }
                            } else {
                                console.warn('[STUB] loadInstalledPluginsDirectly: Failed to load plugins:', data.message);
                            }
                        } catch (error) {
                            console.error('[STUB] loadInstalledPluginsDirectly: Error loading plugins:', error);
                        }
                    },
                    
                    // Stub methods that will be replaced by full implementation
                    loadTabContent: function(tab) {},
                    loadInstalledPlugins: async function() {
                        // Try to use global function if available, otherwise use direct loading
                        if (typeof window.loadInstalledPlugins === 'function') {
                            await window.loadInstalledPlugins();
                            // Update tabs after loading (window.installedPlugins should be set by the global function)
                            if (window.installedPlugins && Array.isArray(window.installedPlugins)) {
                                this.installedPlugins = window.installedPlugins;
                                this.updatePluginTabs();
                            }
                        } else if (typeof window.pluginManager?.loadInstalledPlugins === 'function') {
                            await window.pluginManager.loadInstalledPlugins();
                            // Update tabs after loading
                            if (window.installedPlugins && Array.isArray(window.installedPlugins)) {
                                this.installedPlugins = window.installedPlugins;
                                this.updatePluginTabs();
                            }
                        } else {
                            // Fallback to direct loading (which already calls updatePluginTabs)
                            await this.loadInstalledPluginsDirectly();
                        }
                    },
                    updatePluginTabs: function() {
                        // Basic implementation for stub - will be replaced by full implementation
                        // Debounce to prevent multiple rapid calls
                        if (this._updatePluginTabsTimeout) {
                            clearTimeout(this._updatePluginTabsTimeout);
                        }

                        this._updatePluginTabsTimeout = setTimeout(() => {
                            console.log('[STUB] updatePluginTabs: Executing with', this.installedPlugins?.length || 0, 'plugins');
                            const pluginLists = document.querySelectorAll('.sidebar-plugin-list');
                            if (pluginLists.length === 0) {
                                console.warn('[STUB] updatePluginTabs: Sidebar plugin list not found');
                                return;
                            }
                            if (!this.installedPlugins || this.installedPlugins.length === 0) {
                                console.log('[STUB] updatePluginTabs: No plugins to display');
                                return;
                            }

                            // Check if tabs are already correct by comparing plugin IDs (check first list)
                            const firstList = pluginLists[0];
                            const existingTabs = firstList.querySelectorAll('.plugin-tab');
                            const existingIds = Array.from(existingTabs).map(tab => tab.getAttribute('data-plugin-tab')).sort().join(',');
                            const currentIds = this.installedPlugins.map(p => p.id).sort().join(',');

                            if (existingIds === currentIds && existingTabs.length === this.installedPlugins.length) {
                                console.log('[STUB] updatePluginTabs: Tabs already match, skipping update');
                                return;
                            }

                            pluginLists.forEach(pluginList => {
                                // Clear existing plugin tabs (except Plugin Manager)
                                const existing = pluginList.querySelectorAll('.plugin-tab');
                                existing.forEach(tab => tab.remove());

                                // Add tabs for each installed plugin
                                this.installedPlugins.forEach(plugin => {
                                    const li = document.createElement('li');
                                    li.className = 'nav-item plugin-tab';
                                    li.setAttribute('data-plugin-tab', plugin.id);
                                    const a = document.createElement('a');
                                    a.className = `nav-link ${this.activeTab === plugin.id ? 'active' : ''}`;
                                    a.href = '#';
                                    a.onclick = (e) => {
                                        e.preventDefault();
                                        this.activeTab = plugin.id;
                                        if (typeof this.updatePluginTabStates === 'function') {
                                            this.updatePluginTabStates();
                                        }
                                        closeMobileNav();
                                    };
                                    const div = document.createElement('div');
                                    div.textContent = plugin.name || plugin.id;
                                    a.innerHTML = `<i class="fas fa-puzzle-piece fa-fw"></i> ${div.innerHTML}`;
                                    li.appendChild(a);
                                    pluginList.appendChild(li);
                                });
                            });
                            console.log('[STUB] updatePluginTabs: Added', this.installedPlugins.length, 'plugin tabs');
                        }, 100);
                    },
                    showNotification: function(message, type) {},
                    escapeHtml: function(text) { return String(text || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
                };
            };
        })();
    </script>

    <!-- Alpine.js for reactive components -->
    <!-- Use local file when in AP mode (192.168.4.x) to avoid CDN dependency -->
    <script>
        (function() {
            // Prevent Alpine from auto-initializing by setting deferLoadingAlpine before it loads
            window.deferLoadingAlpine = function(callback) {
                // Wait for DOM to be ready
                function waitForReady() {
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', waitForReady);
                        return;
                    }
                    
                    // app() is already defined in head, so we can initialize Alpine
                    if (callback && typeof callback === 'function') {
                        callback();
                    } else if (window.Alpine && typeof window.Alpine.start === 'function') {
                        // If callback not provided but Alpine is available, start it
                        try {
                            window.Alpine.start();
                        } catch (e) {
                            // Alpine may already be initialized, ignore
                            console.warn('Alpine start error (may already be initialized):', e);
                        }
                    }
                }
                
                waitForReady();
            };
            
            // Detect AP mode by IP address
            const isAPMode = window.location.hostname === '192.168.4.1' || 
                           window.location.hostname.startsWith('192.168.4.');
            
            const alpineSrc = isAPMode ? '/static/v3/js/alpinejs.min.js' : 'https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js';
            const alpineFallback = isAPMode ? 'https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js' : '/static/v3/js/alpinejs.min.js';
            
            const script = document.createElement('script');
            script.defer = true;
            script.src = alpineSrc;
            script.onerror = function() {
                if (alpineSrc !== alpineFallback) {
                    const fallback = document.createElement('script');
                    fallback.defer = true;
                    fallback.src = alpineFallback;
                    document.head.appendChild(fallback);
                }
            };
            document.head.appendChild(script);
        })();
    </script>

    <!-- CodeMirror for JSON editing - lazy loaded when needed -->
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css"></noscript>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css"></noscript>
    <!-- CodeMirror scripts loaded on demand when JSON editor is opened -->
    <script>
        // Lazy load CodeMirror when needed
        window.loadCodeMirror = function() {
            if (window.CodeMirror) return Promise.resolve();
            
            return new Promise((resolve, reject) => {
                const scripts = [
                    'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/json/json.min.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js'
                ];
                
                let loaded = 0;
                scripts.forEach((src, index) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.defer = true;
                    script.onload = () => {
                        loaded++;
                        if (loaded === scripts.length) resolve();
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            });
        };
    </script>

    <!-- Font Awesome icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Custom v3 styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='v3/app.css') }}?v=20260216b">
